================================================================================
                    DBMS PROJECT REPORT
         INSURANCE WORKFLOW AUTOMATION SYSTEM
================================================================================

================================================================================
1. COVER PAGE - TITLE & TEAM DETAILS
================================================================================

Project ID: P04
Project Title: Insurance Workflow Automation System

Team Name: Logicore
Team Members:
1. Aritraghoshdastidar (Scrum Master)
2. bshrikrishna
3. archi829  
4. pes1ug23am077-aiml

Course Details:
- Course Code: UE23CS341A
- Semester: 5th Semester 2025
- Institution: PES University, RR Campus
- Department: AIML Section B

Faculty Guide: Arpitha035
Teaching Assistants: Amrutha-PES, VenomBlood1207

Submission Date: November 4, 2025

================================================================================
2. ABSTRACT - PROJECT DESCRIPTION
================================================================================

The Insurance Workflow Automation System is a comprehensive web-based platform
designed to digitize and automate insurance operations for both customers and
administrators. The system facilitates end-to-end insurance policy lifecycle
management including policy purchase, activation, claims processing, and 
administrative workflows.

Key Objectives:
- Provide customers with an intuitive interface to browse, purchase, and 
  manage multiple types of insurance policies (Health, Life, Auto, Home, 
  Travel, and Accident)
- Automate claim filing and processing with intelligent risk assessment
- Implement role-based access control for customers, administrators, and agents
- Enable four-eyes approval workflow for policy and claim approvals
- Track and audit all sensitive operations for compliance
- Automate notifications and reminders using database triggers

The system addresses real-world challenges in the insurance industry by 
reducing manual paperwork, improving processing efficiency, and providing
transparency to customers throughout their policy lifecycle.

Target Users:
1. Customers: Individuals seeking insurance coverage
2. System Administrators: Policy and claim approval officers
3. Security Officers: Final approval authority
4. Junior Adjusters: Claim processing agents
5. Insurance Agents: Policy assignment and customer service

================================================================================
3. USER REQUIREMENT SPECIFICATIONS
================================================================================

3.1 FUNCTIONAL REQUIREMENTS

FR1: User Authentication and Authorization
- Customers must be able to register with email, name, phone, address, DOB
- Passwords must be securely hashed using bcrypt
- Role-based access: Customer, System Admin, Security Officer, Junior Adjuster
- JWT token-based session management

FR2: Policy Management
- Customers can browse policy catalog with 12+ diverse insurance products
- Filter policies by type (Health, Life, Auto, Home, Travel, Accident)
- View detailed policy information (coverage, premium, features)
- Purchase policies with automatic policy ID generation
- Multi-stage approval workflow (Initial → Final approval)
- Policy status tracking: PENDING_INITIAL_APPROVAL, PENDING_FINAL_APPROVAL,
  INACTIVE_AWAITING_PAYMENT, ACTIVE, DECLINED, EXPIRED

FR3: Claims Processing
- Customers can file claims for active policies
- Automatic risk score calculation (0-10 scale) based on:
  * Claim amount (higher amounts = higher risk)
  * Customer claim history (frequent claimants flagged)
  * Previous declined claims
- Claims assigned to workflow for multi-step processing
- Admin approval/decline with reason tracking

FR4: Payment Processing
- Mock payment activation for policies
- Payment status tracking (SUCCESS, PENDING, FAILED)
- Automatic policy activation upon successful payment
- Payment confirmation notifications

FR5: Workflow Automation
- Configurable workflow templates for claim processing
- Multi-step workflows with MANUAL, API, RULE, TIMER step types
- Automatic workflow assignment to new claims
- Overdue task reporting for administrators
- Workflow performance metrics (usage count, avg processing time)

FR6: Notifications and Reminders
- Automatic notifications via database triggers:
  * Claim status updates
  * Payment confirmations
  * Policy renewal reminders (30 days before expiry)
  * Welcome messages for new policies
- Customer notification dashboard

FR7: Document Processing
- Upload and process claim documents
- Extract structured data from documents (policy ID, amount, date)
- Document verification and validation

FR8: Agent Management
- Auto-assign agents to policies (round-robin distribution)
- Agent workload tracking
- Region-based agent allocation

FR9: Administrative Functions
- View pending policies requiring approval
- View pending claims requiring processing
- High-risk claim alerts (amount > ₹1,000,000 or risk_score > 8)
- Overdue task reporting
- Audit log viewing for compliance

FR10: Reporting and Analytics
- Workflow performance metrics
- Policy statistics by type
- Claim status summaries
- Agent performance reports
- Customer activity analysis

3.2 NON-FUNCTIONAL REQUIREMENTS

NFR1: Security
- Bcrypt password hashing with salt
- JWT token expiration (24 hours)
- Role-based API endpoint protection
- SQL injection prevention using parameterized queries
- Audit logging for sensitive operations

NFR2: Performance
- Database indexing on foreign keys and frequently queried columns
- Response time < 2 seconds for most operations
- Support concurrent user sessions

NFR3: Reliability
- Foreign key constraints to maintain referential integrity
- Transaction management for critical operations
- Error handling and graceful degradation

NFR4: Usability
- Responsive web interface (desktop and mobile)
- Intuitive navigation with React Router
- Clear error messages and user feedback
- Indian Rupee (₹) formatting with locale-specific number display

NFR5: Maintainability
- Modular React components
- RESTful API design
- Comprehensive SQL migration scripts
- Code comments and documentation

NFR6: Scalability
- Junction tables for many-to-many relationships
- JSON configuration for flexible workflow definitions
- Normalized database schema (3NF)

================================================================================
4. SOFTWARES, TOOLS & PROGRAMMING LANGUAGES
================================================================================

4.1 BACKEND TECHNOLOGIES
- Node.js v18+ : JavaScript runtime for server-side execution
- Express.js v5.1.0 : Web application framework
- MySQL 8+ : Relational database management system
- mysql2 v3.15.3 : MySQL client for Node.js with Promise support

4.2 FRONTEND TECHNOLOGIES
- React v19.2.0 : JavaScript library for building user interfaces
- react-router-dom v6.30.1 : Client-side routing
- axios v1.13.0 : HTTP client for API requests
- react-scripts v5.0.1 : Create React App build tooling

4.3 AUTHENTICATION & SECURITY
- bcrypt v5.1.1 : Password hashing algorithm
- jsonwebtoken v9.0.2 : JWT token generation and verification
- jwt-decode v4.0.0 : Client-side JWT decoding

4.4 FILE HANDLING
- multer v2.0.2 : Multipart/form-data handling for file uploads

4.5 UTILITIES
- cors v2.8.5 : Cross-Origin Resource Sharing middleware
- dotenv v16.4.7 : Environment variable management
- body-parser v1.20.3 : Request body parsing middleware

4.6 DEVELOPMENT TOOLS
- npm : Package manager
- Git : Version control
- VS Code : Integrated development environment
- PowerShell : Command-line shell for Windows
- Chrome DevTools : Browser debugging and inspection

4.7 DATABASE TOOLS
- MySQL Workbench : Database design and administration
- MySQL Command Line : Database scripting and automation

4.8 PROGRAMMING LANGUAGES
- JavaScript (ES6+) : Primary development language
- SQL : Database queries and schema definition
- CSS3 : Styling and responsive design
- HTML5 : Web markup

4.9 DEPLOYMENT
- Local Development: Backend (port 3001), Frontend (port 3000)
- Environment: Windows OS with PowerShell

================================================================================
7. DDL COMMANDS
================================================================================

7.1 DATABASE CREATION
------------------------------
CREATE DATABASE IF NOT EXISTS `dbms_database`;
USE `dbms_database`;

7.2 TABLE: administrator
------------------------------
DROP TABLE IF EXISTS `administrator`;
CREATE TABLE `administrator` (
  `admin_id` VARCHAR(50) NOT NULL,
  `name` VARCHAR(100) DEFAULT NULL,
  `email` VARCHAR(100) DEFAULT NULL,
  `phone` VARCHAR(20) DEFAULT NULL,
  `role` VARCHAR(50) DEFAULT NULL COMMENT 'System Admin, Junior Adjuster, Security Officer',
  `password` VARCHAR(255) DEFAULT NULL COMMENT 'bcrypt hashed password',
  PRIMARY KEY (`admin_id`),
  UNIQUE KEY `email` (`email`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci
COMMENT='Administrator users with different roles';

7.3 TABLE: customer
------------------------------
DROP TABLE IF EXISTS `customer`;
CREATE TABLE `customer` (
  `customer_id` VARCHAR(50) NOT NULL,
  `name` VARCHAR(100) DEFAULT NULL,
  `email` VARCHAR(100) DEFAULT NULL,
  `phone` VARCHAR(20) DEFAULT NULL,
  `address` TEXT,
  `dob` DATE DEFAULT NULL,
  `gender` VARCHAR(10) DEFAULT NULL,
  `password` VARCHAR(255) NOT NULL COMMENT 'bcrypt hashed password',
  PRIMARY KEY (`customer_id`),
  UNIQUE KEY `email` (`email`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci
COMMENT='Customer profiles with authentication';

7.4 TABLE: agent
------------------------------
DROP TABLE IF EXISTS `agent`;
CREATE TABLE `agent` (
  `agent_id` VARCHAR(50) NOT NULL,
  `name` VARCHAR(100) DEFAULT NULL,
  `email` VARCHAR(100) DEFAULT NULL,
  `phone` VARCHAR(20) DEFAULT NULL,
  `region` VARCHAR(100) DEFAULT NULL,
  PRIMARY KEY (`agent_id`),
  UNIQUE KEY `email` (`email`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci
COMMENT='Insurance agents';

7.5 TABLE: policy
------------------------------
DROP TABLE IF EXISTS `policy`;
CREATE TABLE `policy` (
  `policy_id` VARCHAR(50) NOT NULL,
  `policy_type` VARCHAR(50) DEFAULT NULL,
  `coverage_amount` DECIMAL(15,2) DEFAULT NULL,
  `premium_amount` DECIMAL(10,2) DEFAULT NULL,
  `start_date` DATE DEFAULT NULL,
  `end_date` DATE DEFAULT NULL,
  `status` ENUM('PENDING_INITIAL_APPROVAL','PENDING_FINAL_APPROVAL',
                'INACTIVE_AWAITING_PAYMENT','ACTIVE','DECLINED','EXPIRED') 
         DEFAULT 'PENDING_INITIAL_APPROVAL',
  `initial_approval_by` VARCHAR(50) DEFAULT NULL,
  `initial_approval_date` TIMESTAMP NULL DEFAULT NULL,
  `final_approval_by` VARCHAR(50) DEFAULT NULL,
  `final_approval_date` TIMESTAMP NULL DEFAULT NULL,
  PRIMARY KEY (`policy_id`),
  KEY `initial_approval_by` (`initial_approval_by`),
  KEY `final_approval_by` (`final_approval_by`),
  CONSTRAINT `fk_policy_initial_approver` 
    FOREIGN KEY (`initial_approval_by`) REFERENCES `administrator` (`admin_id`),
  CONSTRAINT `fk_policy_final_approver` 
    FOREIGN KEY (`final_approval_by`) REFERENCES `administrator` (`admin_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci
COMMENT='Insurance policies with four-eyes approval';

7.6 TABLE: beneficiary
------------------------------
DROP TABLE IF EXISTS `beneficiary`;
CREATE TABLE `beneficiary` (
  `beneficiary_id` INT NOT NULL AUTO_INCREMENT,
  `policy_id` VARCHAR(50) DEFAULT NULL,
  `name` VARCHAR(100) DEFAULT NULL,
  `relationship` VARCHAR(50) DEFAULT NULL,
  `phone` VARCHAR(20) DEFAULT NULL,
  `allocation_percentage` DECIMAL(5,2) DEFAULT NULL,
  PRIMARY KEY (`beneficiary_id`),
  KEY `policy_id` (`policy_id`),
  CONSTRAINT `fk_beneficiary_policy` 
    FOREIGN KEY (`policy_id`) REFERENCES `policy` (`policy_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci
COMMENT='Policy beneficiaries';

7.7 TABLE: customer_policy (Junction Table)
------------------------------
DROP TABLE IF EXISTS `customer_policy`;
CREATE TABLE `customer_policy` (
  `customer_policy_id` INT NOT NULL AUTO_INCREMENT,
  `customer_id` VARCHAR(50) NOT NULL,
  `policy_id` VARCHAR(50) NOT NULL,
  PRIMARY KEY (`customer_policy_id`),
  KEY `fk_cp_customer` (`customer_id`),
  KEY `fk_cp_policy` (`policy_id`),
  CONSTRAINT `fk_cp_customer` 
    FOREIGN KEY (`customer_id`) REFERENCES `customer` (`customer_id`),
  CONSTRAINT `fk_cp_policy` 
    FOREIGN KEY (`policy_id`) REFERENCES `policy` (`policy_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci
COMMENT='Customer-Policy relationship (many-to-many)';

7.8 TABLE: agent_policy (Junction Table)
------------------------------
DROP TABLE IF EXISTS `agent_policy`;
CREATE TABLE `agent_policy` (
  `agent_policy_id` INT NOT NULL AUTO_INCREMENT,
  `agent_id` VARCHAR(50) NOT NULL,
  `policy_id` VARCHAR(50) NOT NULL,
  PRIMARY KEY (`agent_policy_id`),
  KEY `fk_ap_agent` (`agent_id`),
  KEY `fk_ap_policy` (`policy_id`),
  CONSTRAINT `fk_ap_agent` 
    FOREIGN KEY (`agent_id`) REFERENCES `agent` (`agent_id`),
  CONSTRAINT `fk_ap_policy` 
    FOREIGN KEY (`policy_id`) REFERENCES `policy` (`policy_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci
COMMENT='Agent-Policy assignment (many-to-many)';

7.9 TABLE: claim
------------------------------
DROP TABLE IF EXISTS `claim`;
CREATE TABLE `claim` (
  `claim_id` VARCHAR(50) NOT NULL,
  `claim_amount` DECIMAL(15,2) DEFAULT NULL,
  `claim_status` VARCHAR(50) DEFAULT 'PENDING',
  `claim_date` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
  `customer_id` VARCHAR(50) DEFAULT NULL,
  `policy_id` VARCHAR(50) DEFAULT NULL,
  `description` TEXT,
  `risk_score` INT DEFAULT 0 COMMENT 'Risk assessment score (0-10)',
  `workflow_id` VARCHAR(50) DEFAULT NULL,
  `current_step` INT DEFAULT NULL,
  `assigned_to` VARCHAR(50) DEFAULT NULL COMMENT 'Admin ID assigned to process',
  `processing_time` INT DEFAULT NULL COMMENT 'Processing time in hours',
  PRIMARY KEY (`claim_id`),
  KEY `customer_id` (`customer_id`),
  KEY `policy_id` (`policy_id`),
  KEY `assigned_to` (`assigned_to`),
  CONSTRAINT `fk_claim_customer` 
    FOREIGN KEY (`customer_id`) REFERENCES `customer` (`customer_id`),
  CONSTRAINT `fk_claim_policy` 
    FOREIGN KEY (`policy_id`) REFERENCES `policy` (`policy_id`),
  CONSTRAINT `fk_claim_admin` 
    FOREIGN KEY (`assigned_to`) REFERENCES `administrator` (`admin_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci
COMMENT='Insurance claims with workflow integration';

7.10 TABLE: payment
------------------------------
DROP TABLE IF EXISTS `payment`;
CREATE TABLE `payment` (
  `payment_id` VARCHAR(50) NOT NULL,
  `customer_policy_id` INT DEFAULT NULL,
  `status` VARCHAR(50) DEFAULT NULL,
  `payment_date` TIMESTAMP NULL DEFAULT NULL,
  `payment_mode` VARCHAR(30) DEFAULT NULL,
  PRIMARY KEY (`payment_id`),
  KEY `fk_payment_customer_policy` (`customer_policy_id`),
  CONSTRAINT `fk_payment_customer_policy` 
    FOREIGN KEY (`customer_policy_id`) REFERENCES `customer_policy` (`customer_policy_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci
COMMENT='Payment transactions';

7.11 TABLE: reminder
------------------------------
DROP TABLE IF EXISTS `reminder`;
CREATE TABLE `reminder` (
  `notification_id` VARCHAR(50) NOT NULL,
  `notification_date` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
  `status` VARCHAR(20) DEFAULT 'PENDING',
  `message` TEXT,
  `type` VARCHAR(50) DEFAULT NULL 
    COMMENT 'CLAIM_UPDATE, POLICY_RENEWAL, PAYMENT_DUE, etc.',
  `customer_id` VARCHAR(50) DEFAULT NULL,
  PRIMARY KEY (`notification_id`),
  KEY `customer_id` (`customer_id`),
  CONSTRAINT `fk_reminder_customer` 
    FOREIGN KEY (`customer_id`) REFERENCES `customer` (`customer_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci
COMMENT='Notification and reminder system';

7.12 TABLE: admin_reminder (Junction Table)
------------------------------
DROP TABLE IF EXISTS `admin_reminder`;
CREATE TABLE `admin_reminder` (
  `id` VARCHAR(50) NOT NULL,
  `notification_id` VARCHAR(50) DEFAULT NULL,
  `admin_id` VARCHAR(50) DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `notification_id` (`notification_id`),
  KEY `admin_id` (`admin_id`),
  CONSTRAINT `admin_reminder_ibfk_1` 
    FOREIGN KEY (`notification_id`) REFERENCES `reminder` (`notification_id`),
  CONSTRAINT `admin_reminder_ibfk_2` 
    FOREIGN KEY (`admin_id`) REFERENCES `administrator` (`admin_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci
COMMENT='Admin-specific reminders';

7.13 TABLE: audit_log
------------------------------
DROP TABLE IF EXISTS `audit_log`;
CREATE TABLE `audit_log` (
  `audit_log_id` INT AUTO_INCREMENT PRIMARY KEY,
  `user_id` VARCHAR(50) NOT NULL,
  `user_type` ENUM('CUSTOMER', 'ADMIN') NOT NULL,
  `action_type` VARCHAR(100) NOT NULL,
  `entity_id` VARCHAR(50) DEFAULT NULL 
    COMMENT 'ID of affected entity (claim_id, policy_id, etc.)',
  `timestamp` TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  `details` JSON DEFAULT NULL 
    COMMENT 'Optional details like data before/after change'
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci
COMMENT='Audit log for sensitive user actions and compliance';

7.14 TABLE: workflows
------------------------------
DROP TABLE IF EXISTS `workflows`;
CREATE TABLE `workflows` (
  `workflow_id` VARCHAR(50) NOT NULL,
  `workflow_name` VARCHAR(100) DEFAULT NULL,
  `description` TEXT,
  `created_at` TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  PRIMARY KEY (`workflow_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci
COMMENT='Workflow definitions';

7.15 TABLE: workflow_steps
------------------------------
DROP TABLE IF EXISTS `workflow_steps`;
CREATE TABLE `workflow_steps` (
  `step_id` INT NOT NULL AUTO_INCREMENT,
  `workflow_id` VARCHAR(50) DEFAULT NULL,
  `step_number` INT DEFAULT NULL,
  `step_name` VARCHAR(100) DEFAULT NULL,
  `step_type` ENUM('MANUAL', 'API', 'RULE', 'TIMER') DEFAULT 'MANUAL',
  `configuration` JSON DEFAULT NULL COMMENT 'Step-specific configuration',
  `status` VARCHAR(20) DEFAULT 'PENDING',
  `due_date` TIMESTAMP NULL DEFAULT NULL,
  PRIMARY KEY (`step_id`),
  KEY `workflow_id` (`workflow_id`),
  CONSTRAINT `fk_workflow_steps` 
    FOREIGN KEY (`workflow_id`) REFERENCES `workflows` (`workflow_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci
COMMENT='Workflow step definitions with JSON configuration';

7.16 INDEX CREATION
------------------------------
-- Performance indexes on frequently queried columns
CREATE INDEX idx_policy_status ON policy(status);
CREATE INDEX idx_claim_status ON claim(claim_status);
CREATE INDEX idx_claim_risk_score ON claim(risk_score);
CREATE INDEX idx_claim_amount ON claim(claim_amount);
CREATE INDEX idx_policy_dates ON policy(start_date, end_date);
CREATE INDEX idx_workflow_steps_status ON workflow_steps(status);

================================================================================
9. LIST OF FUNCTIONALITIES/FEATURES
================================================================================

9.1 CUSTOMER FEATURES
------------------------------
✓ User Registration and Login
  - Email-based registration with password hashing
  - Secure authentication with JWT tokens
  - Profile management (name, phone, address, DOB, gender)

✓ Policy Catalog Browsing
  - View 12+ insurance products across 6 categories
  - Filter policies by type (Health, Life, Auto, Home, Travel, Accident)
  - See detailed policy information:
    * Coverage amount (up to ₹50,00,000)
    * Premium amount (₹1,200 to ₹32,000)
    * Key features (4-5 benefits per policy)
    * Popular policies highlighted with badges
  - Responsive card-based UI with gradient icons

✓ Policy Purchase
  - One-click policy purchase with confirmation
  - Automatic policy ID generation (POL_timestamp)
  - Links policy to customer account
  - Initial status: PENDING_INITIAL_APPROVAL

✓ My Policies Dashboard
  - View all purchased policies
  - See policy status (PENDING, INACTIVE, ACTIVE, DECLINED, EXPIRED)
  - Policy details: type, coverage, premium, dates
  - Mock payment activation for approved policies

✓ Claims Management
  - File claims for linked policies
  - Dropdown shows only user's policies
  - Enter claim amount and description
  - Automatic claim ID generation (CLM_timestamp)
  - Automatic risk score calculation
  - View claim history with status tracking

✓ Document Upload
  - Upload claim-related documents
  - Automatic data extraction (policy ID, amount, date)
  - Document verification

✓ Notifications
  - View pending notifications
  - Claim status updates
  - Payment confirmations
  - Policy renewal reminders

9.2 ADMINISTRATOR FEATURES
------------------------------
✓ Admin Login
  - Role-based authentication (System Admin, Security Officer, Junior Adjuster)
  - JWT token with role identification

✓ Policy Approval Workflow
  - View pending policies requiring initial approval
  - Four-eyes principle: Initial approver ≠ Final approver
  - Approve or decline with reason
  - Status transitions:
    * PENDING_INITIAL_APPROVAL → PENDING_FINAL_APPROVAL (after initial)
    * PENDING_FINAL_APPROVAL → INACTIVE_AWAITING_PAYMENT (after final)
    * PENDING → DECLINED (if rejected)

✓ Claim Processing
  - View pending claims with customer details
  - Approve or decline claims
  - Assign claims to workflow steps
  - Track processing time

✓ High-Risk Alerts
  - Automatic flagging of high-risk claims:
    * Claim amount > ₹1,000,000
    * Risk score > 8
  - View customer history
  - Prioritize for investigation

✓ Overdue Tasks Report
  - View workflow steps past due date
  - Calculate average overdue days
  - Filter by workflow type
  - Admin-only access for compliance

✓ Workflow Management
  - Create and edit workflow templates
  - Define multi-step approval processes
  - Configure step types (MANUAL, API, RULE, TIMER)
  - JSON-based step configuration

✓ Workflow Metrics Dashboard
  - Usage count per workflow
  - Average processing time
  - Approval/Decline ratios
  - Performance analytics

✓ Adjuster Dashboard
  - View assigned claims
  - Process claims by workflow step
  - Update claim status

9.3 SYSTEM FEATURES
------------------------------
✓ Automated Notifications (via Triggers)
  - Claim status change notifications
  - Payment success confirmations
  - New policy welcome messages
  - Policy renewal reminders (30 days before expiry)

✓ Automatic Agent Assignment
  - Round-robin agent allocation
  - Workload balancing
  - Region-based assignment

✓ Risk Assessment
  - Automatic risk score calculation (0-10 scale):
    * Amount-based: < ₹10K=1, < ₹50K=2, < ₹1L=3, < ₹5L=5, 
                    < ₹10L=7, < ₹50L=8, < ₹1Cr=9, ≥₹1Cr=10
    * History adjustment: +1 if > 5 claims
    * Declined history: +1 if any declined claims
  - High-risk claim flagging

✓ Audit Logging
  - Track sensitive operations
  - User ID and action type logging
  - JSON details for before/after state
  - Compliance and security monitoring

✓ Data Integrity
  - Foreign key constraints enforcement
  - Referential integrity maintenance
  - Transaction management
  - Input validation

✓ Session Management
  - JWT token expiration (24 hours)
  - Automatic logout on token expiry
  - Secure token storage

================================================================================
10. TRIGGERS, PROCEDURES, NESTED QUERIES, JOINS, AGGREGATES
================================================================================

10.1 TRIGGERS (5 Total)
------------------------------

TRIGGER 1: after_claim_status_update
------------------------------
Purpose: Automatically notify customer when claim status changes
Type: AFTER UPDATE on claim table
Logic:
  - Checks if claim_status actually changed
  - Generates unique notification ID
  - Inserts or updates reminder record
  - Sets status to PENDING, type to CLAIM_UPDATE

Code:
CREATE TRIGGER `after_claim_status_update` 
AFTER UPDATE ON `claim` 
FOR EACH ROW 
BEGIN
    DECLARE v_notification_id VARCHAR(50);
    
    IF OLD.claim_status != NEW.claim_status THEN
        SET v_notification_id = CONCAT('NOTIF_CLM_', NEW.claim_id, '_STATUS');
        
        INSERT INTO reminder (
            notification_id, notification_date, status, message, 
            type, customer_id
        )
        VALUES (
            v_notification_id, NOW(), 'PENDING',
            CONCAT('Your claim ', NEW.claim_id, 
                   ' status has been updated to: ', NEW.claim_status),
            'CLAIM_UPDATE', NEW.customer_id
        )
        ON DUPLICATE KEY UPDATE
            notification_date = NOW(),
            message = CONCAT('Your claim ', NEW.claim_id, 
                           ' status has been updated to: ', NEW.claim_status),
            status = 'PENDING';
    END IF;
END;

TRIGGER 2: after_payment_success
------------------------------
Purpose: Activate policy and notify customer after payment
Type: AFTER INSERT on payment table
Logic:
  - Checks if payment status = 'SUCCESS'
  - Retrieves policy_id and customer_id from customer_policy
  - Updates policy status to ACTIVE
  - Creates payment confirmation notification

Code:
CREATE TRIGGER `after_payment_success` 
AFTER INSERT ON `payment` 
FOR EACH ROW 
BEGIN
    DECLARE v_policy_id VARCHAR(50);
    DECLARE v_customer_id VARCHAR(50);
    DECLARE v_notification_id VARCHAR(50);
    
    IF NEW.status = 'SUCCESS' THEN
        SELECT cp.policy_id, cp.customer_id
        INTO v_policy_id, v_customer_id
        FROM customer_policy cp
        WHERE cp.customer_policy_id = NEW.customer_policy_id;
        
        UPDATE policy
        SET status = 'ACTIVE'
        WHERE policy_id = v_policy_id;
        
        SET v_notification_id = CONCAT('NOTIF_PAY_', NEW.payment_id);
        
        INSERT INTO reminder (
            notification_id, notification_date, status, message, 
            type, customer_id
        )
        VALUES (
            v_notification_id, NOW(), 'PENDING',
            CONCAT('Payment successful! Your policy ', 
                   v_policy_id, ' is now ACTIVE.'),
            'PAYMENT_SUCCESS', v_customer_id
        );
    END IF;
END;

TRIGGER 3: after_policy_insert
------------------------------
Purpose: Welcome notification when new policy created
Type: AFTER INSERT on policy table
Logic:
  - Retrieves customer_id from customer_policy
  - Creates welcome notification
  - Sets type to POLICY_CREATED

Code:
CREATE TRIGGER `after_policy_insert` 
AFTER INSERT ON `policy` 
FOR EACH ROW 
BEGIN
    DECLARE v_customer_id VARCHAR(50);
    DECLARE v_notification_id VARCHAR(50);
    
    SELECT customer_id INTO v_customer_id
    FROM customer_policy
    WHERE policy_id = NEW.policy_id
    LIMIT 1;
    
    IF v_customer_id IS NOT NULL THEN
        SET v_notification_id = CONCAT('NOTIF_POL_', NEW.policy_id, '_WELCOME');
        
        INSERT IGNORE INTO reminder (
            notification_id, notification_date, status, message, 
            type, customer_id
        )
        VALUES (
            v_notification_id, NOW(), 'PENDING',
            CONCAT('Welcome! Your new ', NEW.policy_type, 
                   ' policy ', NEW.policy_id, 
                   ' has been created. Awaiting approval.'),
            'POLICY_CREATED', v_customer_id
        );
    END IF;
END;

TRIGGER 4: policy_renewal_reminder
------------------------------
Purpose: Create reminder for policies expiring within 30 days
Type: BEFORE UPDATE on policy table
Logic:
  - Checks if policy is ACTIVE
  - Calculates days until expiry (1-30 days)
  - Creates renewal reminder notification

Code:
CREATE TRIGGER `policy_renewal_reminder` 
BEFORE UPDATE ON `policy` 
FOR EACH ROW 
BEGIN
    DECLARE v_customer_id VARCHAR(50);
    DECLARE v_notification_id VARCHAR(50);
    
    IF NEW.status = 'ACTIVE' 
       AND DATEDIFF(NEW.end_date, NOW()) <= 30 
       AND DATEDIFF(NEW.end_date, NOW()) > 0 THEN
        
        SELECT customer_id INTO v_customer_id
        FROM customer_policy
        WHERE policy_id = NEW.policy_id
        LIMIT 1;
        
        IF v_customer_id IS NOT NULL THEN
            SET v_notification_id = CONCAT('NOTIF_POL_', 
                                          NEW.policy_id, '_RENEWAL');
            
            INSERT IGNORE INTO reminder (
                notification_id, notification_date, status, 
                message, type, customer_id
            )
            VALUES (
                v_notification_id, NOW(), 'PENDING',
                CONCAT('Your policy ', NEW.policy_id, 
                       ' expires on ', NEW.end_date, 
                       '. Please renew soon!'),
                'POLICY_RENEWAL', v_customer_id
            );
        END IF;
    END IF;
END;

TRIGGER 5: after_policy_insert_assign_agent
------------------------------
Purpose: Auto-assign agent to new policy (round-robin)
Type: AFTER INSERT on policy table
Logic:
  - Finds agent with least assignments
  - Excludes already assigned agents
  - Inserts into agent_policy junction table

Code:
CREATE TRIGGER `after_policy_insert_assign_agent` 
AFTER INSERT ON `policy` 
FOR EACH ROW 
BEGIN
    DECLARE v_agent_id VARCHAR(50);
    
    SELECT agent_id INTO v_agent_id
    FROM agent
    WHERE agent_id NOT IN (
        SELECT agent_id 
        FROM agent_policy 
        WHERE policy_id = NEW.policy_id
    )
    ORDER BY (
        SELECT COUNT(*) 
        FROM agent_policy ap 
        WHERE ap.agent_id = agent.agent_id
    ) ASC
    LIMIT 1;
    
    IF v_agent_id IS NOT NULL THEN
        INSERT IGNORE INTO agent_policy (agent_id, policy_id)
        VALUES (v_agent_id, NEW.policy_id);
    END IF;
END;

10.2 JOIN QUERIES
------------------------------

QUERY 1: Customer Policies with Details (3-table JOIN)
------------------------------
Purpose: Get all policies for a customer with full details
Tables: policy, customer_policy, customer
Join Type: INNER JOIN

SELECT 
    p.policy_id,
    p.policy_type,
    p.coverage_amount,
    p.premium_amount,
    p.start_date,
    p.end_date,
    p.status,
    cp.customer_policy_id,
    c.customer_id,
    c.name AS customer_name,
    c.email
FROM policy p
JOIN customer_policy cp ON p.policy_id = cp.policy_id
JOIN customer c ON cp.customer_id = c.customer_id
WHERE c.customer_id = ?
ORDER BY p.start_date DESC;

QUERY 2: Claims with Full Context (4-table JOIN)
------------------------------
Purpose: Get claims with customer, policy, and admin info
Tables: claim, customer, policy, administrator
Join Type: INNER JOIN + LEFT JOIN

SELECT 
    c.claim_id,
    c.claim_amount,
    c.claim_status,
    c.claim_date,
    c.description,
    c.risk_score,
    cu.customer_id,
    cu.name AS customer_name,
    cu.email AS customer_email,
    p.policy_id,
    p.policy_type,
    p.coverage_amount,
    a.admin_id,
    a.name AS assigned_admin,
    a.role AS admin_role
FROM claim c
JOIN customer cu ON c.customer_id = cu.customer_id
JOIN policy p ON c.policy_id = p.policy_id
LEFT JOIN administrator a ON c.assigned_to = a.admin_id
WHERE c.claim_status = 'PENDING'
ORDER BY c.claim_date DESC;

QUERY 3: Agent Performance (4-table JOIN with DISTINCT)
------------------------------
Purpose: Analyze agent workload and policy assignments
Tables: agent, agent_policy, policy, customer_policy

SELECT 
    a.agent_id,
    a.name AS agent_name,
    a.region,
    COUNT(DISTINCT ap.policy_id) AS assigned_policies,
    COUNT(DISTINCT cp.customer_id) AS unique_customers,
    SUM(p.coverage_amount) AS total_coverage_managed,
    AVG(p.premium_amount) AS avg_policy_premium
FROM agent a
LEFT JOIN agent_policy ap ON a.agent_id = ap.agent_id
LEFT JOIN policy p ON ap.policy_id = p.policy_id
LEFT JOIN customer_policy cp ON p.policy_id = cp.policy_id
GROUP BY a.agent_id, a.name, a.region
ORDER BY assigned_policies DESC;

10.3 NESTED QUERIES (SUBQUERIES)
------------------------------

QUERY 1: High-Risk Claims Alert (Nested IN subquery)
------------------------------
Purpose: Find claims with high amounts or risk scores

SELECT * FROM claim
WHERE claim_id IN (
    SELECT claim_id 
    FROM claim 
    WHERE claim_amount > 1000000 OR risk_score > 8
)
ORDER BY claim_date DESC;

QUERY 2: Customers with Multiple Claims (Correlated subqueries)
------------------------------
Purpose: Find high-activity customers

SELECT 
    c.customer_id,
    c.name,
    c.email,
    (SELECT COUNT(*) 
     FROM claim cl 
     WHERE cl.customer_id = c.customer_id) AS total_claims,
    (SELECT SUM(cl.claim_amount) 
     FROM claim cl 
     WHERE cl.customer_id = c.customer_id) AS total_claimed_amount,
    (SELECT COUNT(*) 
     FROM claim cl 
     WHERE cl.customer_id = c.customer_id 
     AND cl.claim_status = 'APPROVED') AS approved_claims
FROM customer c
WHERE (SELECT COUNT(*) 
       FROM claim cl 
       WHERE cl.customer_id = c.customer_id) > 1
ORDER BY total_claims DESC;

QUERY 3: Least Assigned Agent (Nested subquery for MIN)
------------------------------
Purpose: Find agent with fewest policy assignments

SELECT agent_id, name
FROM agent
WHERE agent_id = (
    SELECT agent_id
    FROM agent_policy
    GROUP BY agent_id
    ORDER BY COUNT(*) ASC
    LIMIT 1
);

10.4 AGGREGATE QUERIES
------------------------------

QUERY 1: Workflow Performance Metrics (Multiple aggregates)
------------------------------
Purpose: Calculate usage and processing time per workflow

SELECT 
    w.workflow_id,
    w.workflow_name,
    COUNT(c.claim_id) AS usage_count,
    AVG(c.processing_time) AS avg_processing_time_hours,
    MIN(c.processing_time) AS min_processing_time,
    MAX(c.processing_time) AS max_processing_time,
    SUM(CASE WHEN c.claim_status = 'APPROVED' THEN 1 ELSE 0 END) AS approved_count,
    SUM(CASE WHEN c.claim_status = 'DECLINED' THEN 1 ELSE 0 END) AS declined_count
FROM workflows w
LEFT JOIN claim c ON w.workflow_id = c.workflow_id
GROUP BY w.workflow_id, w.workflow_name
HAVING COUNT(c.claim_id) > 0
ORDER BY usage_count DESC;

QUERY 2: Overdue Tasks with HAVING clause
------------------------------
Purpose: Find overdue workflow steps with counts

SELECT 
    ws.workflow_id,
    w.workflow_name,
    ws.step_name,
    COUNT(*) AS overdue_count,
    AVG(DATEDIFF(NOW(), ws.due_date)) AS avg_overdue_days,
    MIN(ws.due_date) AS earliest_due_date,
    MAX(ws.due_date) AS latest_due_date
FROM workflow_steps ws
JOIN workflows w ON ws.workflow_id = w.workflow_id
WHERE ws.status = 'PENDING' AND ws.due_date < NOW()
GROUP BY ws.workflow_id, w.workflow_name, ws.step_name
HAVING COUNT(*) > 0
ORDER BY avg_overdue_days DESC;

QUERY 3: Policy Statistics by Type (Complex aggregate)
------------------------------
Purpose: Analyze policy distribution and revenue

SELECT 
    p.policy_type,
    COUNT(DISTINCT p.policy_id) AS total_policies,
    COUNT(DISTINCT cp.customer_id) AS total_customers,
    SUM(p.coverage_amount) AS total_coverage,
    SUM(p.premium_amount) AS total_premium_revenue,
    AVG(p.premium_amount) AS avg_premium,
    COUNT(CASE WHEN p.status = 'ACTIVE' THEN 1 END) AS active_policies,
    COUNT(CASE WHEN p.status = 'PENDING_INITIAL_APPROVAL' 
          THEN 1 END) AS pending_policies
FROM policy p
LEFT JOIN customer_policy cp ON p.policy_id = cp.policy_id
GROUP BY p.policy_type
ORDER BY total_premium_revenue DESC;

QUERY 4: Claim Status Summary (Aggregate with CASE)
------------------------------
Purpose: Dashboard statistics for last 30 days

SELECT 
    COUNT(*) AS total_claims,
    SUM(claim_amount) AS total_claim_amount,
    AVG(claim_amount) AS avg_claim_amount,
    COUNT(CASE WHEN claim_status = 'PENDING' THEN 1 END) AS pending_claims,
    COUNT(CASE WHEN claim_status = 'APPROVED' THEN 1 END) AS approved_claims,
    COUNT(CASE WHEN claim_status = 'DECLINED' THEN 1 END) AS declined_claims,
    SUM(CASE WHEN claim_status = 'APPROVED' 
        THEN claim_amount ELSE 0 END) AS approved_amount,
    AVG(CASE WHEN claim_status = 'APPROVED' 
        THEN processing_time END) AS avg_approval_time
FROM claim
WHERE claim_date >= DATE_SUB(NOW(), INTERVAL 30 DAY);

================================================================================
11. CODE SNIPPETS FOR INVOKING PROCEDURES/FUNCTIONS/TRIGGERS
================================================================================

11.1 TRIGGER INVOCATIONS
------------------------------

Trigger 1: after_claim_status_update
Invocation: Automatically fires when claim status is updated

-- Admin approves a claim (triggers notification)
UPDATE claim 
SET claim_status = 'APPROVED', 
    assigned_to = 'ADMIN001'
WHERE claim_id = 'CLM_1762013410523';

-- Result: Creates notification in reminder table:
-- notification_id: NOTIF_CLM_CLM_1762013410523_STATUS
-- message: "Your claim CLM_1762013410523 status has been updated to: APPROVED"

Trigger 2: after_payment_success
Invocation: Automatically fires when payment record inserted

-- Customer makes payment (triggers policy activation)
INSERT INTO payment (payment_id, customer_policy_id, status, 
                     payment_date, payment_mode)
VALUES ('PAY_1234567890', 1, 'SUCCESS', NOW(), 'CREDIT_CARD');

-- Result: 
-- 1. Updates policy status to ACTIVE
-- 2. Creates payment success notification in reminder table

Trigger 3: after_policy_insert
Invocation: Automatically fires when new policy created

-- Customer purchases policy (triggers welcome notification)
INSERT INTO policy (policy_id, policy_type, coverage_amount, 
                    premium_amount, start_date, end_date, status)
VALUES ('POL_1234567890', 'HEALTH', 500000.00, 12000.00, 
        '2025-01-01', '2026-01-01', 'PENDING_INITIAL_APPROVAL');

-- Then link to customer
INSERT INTO customer_policy (customer_id, policy_id)
VALUES ('CUST001', 'POL_1234567890');

-- Result: Creates welcome notification with policy details

Trigger 4: policy_renewal_reminder
Invocation: Automatically fires when policy updated

-- System updates policy (triggers renewal reminder if expiring soon)
UPDATE policy 
SET status = 'ACTIVE'
WHERE policy_id = 'POL_1234567890';

-- Result: If end_date within 30 days, creates renewal reminder

Trigger 5: after_policy_insert_assign_agent
Invocation: Automatically fires when new policy created

-- New policy creation (triggers agent assignment)
INSERT INTO policy (policy_id, policy_type, coverage_amount, 
                    premium_amount, start_date, end_date)
VALUES ('POL_9876543210', 'AUTO', 300000.00, 8000.00, 
        '2025-01-01', '2026-01-01');

-- Result: Automatically assigns agent with least workload to policy
-- Creates record in agent_policy table

11.2 APPLICATION-LEVEL FUNCTION INVOCATIONS
------------------------------

Risk Score Calculation Function (Server.js)
Location: POST /api/my-claims endpoint

Function Logic:
function calculateRiskScore(amount, customerHistory) {
    let score = 0;
    
    // Amount-based scoring (0-10 scale)
    if (amount < 10000) score = 1;
    else if (amount < 50000) score = 2;
    else if (amount < 100000) score = 3;
    else if (amount < 500000) score = 5;
    else if (amount < 1000000) score = 7;
    else if (amount < 5000000) score = 8;
    else if (amount < 10000000) score = 9;
    else score = 10;
    
    // History adjustments
    if (customerHistory.totalClaims > 5) score += 1;
    if (customerHistory.hasDeclinedClaims) score += 1;
    
    return Math.min(score, 10); // Cap at 10
}

Invocation Example:
// When customer files a claim
const claimAmount = 1500000; // ₹15 lakhs
const customerHistory = {
    totalClaims: 6,
    hasDeclinedClaims: false
};

const riskScore = calculateRiskScore(claimAmount, customerHistory);
// Result: score = 7 (high amount) + 1 (>5 claims) = 8

-- SQL insertion with risk score
INSERT INTO claim (claim_id, claim_amount, risk_score, ...)
VALUES ('CLM_123', 1500000, 8, ...);

JWT Token Generation (Server.js)
Location: POST /api/login endpoint

Function Code:
const jwt = require('jsonwebtoken');

function generateToken(user) {
    const payload = {
        customerId: user.customer_id,
        email: user.email,
        name: user.name,
        isAdmin: false
    };
    
    return jwt.sign(payload, process.env.JWT_SECRET, {
        expiresIn: '24h'
    });
}

Invocation Example:
// After successful login
const user = { 
    customer_id: 'CUST001', 
    email: 'john@example.com',
    name: 'John Doe'
};

const token = generateToken(user);
// Result: JWT token valid for 24 hours
// Client stores in localStorage and sends in Authorization header

Password Hashing (Server.js)
Location: POST /api/register endpoint

Function Code:
const bcrypt = require('bcrypt');

async function hashPassword(plainPassword) {
    const saltRounds = 10;
    return await bcrypt.hash(plainPassword, saltRounds);
}

async function verifyPassword(plainPassword, hashedPassword) {
    return await bcrypt.compare(plainPassword, hashedPassword);
}

Invocation Example:
// During registration
const password = 'SecurePass123';
const hashedPassword = await hashPassword(password);
// Result: $2b$10$randomsalt...hashedpassword

INSERT INTO customer (customer_id, email, password, ...)
VALUES ('CUST001', 'john@example.com', hashedPassword, ...);

// During login
const isValid = await verifyPassword(inputPassword, storedHashedPassword);
if (isValid) {
    // Generate token and login
}

11.3 COMPLEX QUERY INVOCATIONS
------------------------------

High-Risk Claims Alert Query
Endpoint: GET /api/alerts/highrisk

SQL Execution:
SELECT 
    c.claim_id, c.claim_amount, c.claim_status, c.claim_date, 
    c.risk_score, c.description,
    cu.customer_id, cu.name AS customer_name, cu.email,
    p.policy_id, p.policy_type
FROM claim c
JOIN customer cu ON c.customer_id = cu.customer_id
JOIN policy p ON c.policy_id = p.policy_id
WHERE c.claim_amount > 1000000 OR c.risk_score > 8
ORDER BY c.claim_date DESC;

Frontend Invocation (HighRiskAlerts.js):
useEffect(() => {
    const token = localStorage.getItem('token');
    axios.get('http://localhost:3001/api/alerts/highrisk', {
        headers: { Authorization: `Bearer ${token}` }
    })
    .then(response => {
        setAlerts(response.data);
    })
    .catch(error => {
        console.error('Error fetching alerts:', error);
    });
}, []);

Workflow Metrics Query
Endpoint: GET /api/metrics/workflows

SQL Execution:
SELECT 
    w.workflow_id, w.workflow_name,
    COUNT(c.claim_id) AS usage_count,
    AVG(c.processing_time) AS avg_processing_time_hours,
    SUM(CASE WHEN c.claim_status = 'APPROVED' THEN 1 ELSE 0 END) AS approved,
    SUM(CASE WHEN c.claim_status = 'DECLINED' THEN 1 ELSE 0 END) AS declined
FROM workflows w
LEFT JOIN claim c ON w.workflow_id = c.workflow_id
GROUP BY w.workflow_id, w.workflow_name
HAVING COUNT(c.claim_id) > 0
ORDER BY usage_count DESC;

Frontend Invocation (WorkflowMetricsDashboard.js):
const fetchMetrics = async () => {
    const response = await axios.get(
        'http://localhost:3001/api/metrics/workflows'
    );
    setMetrics(response.data);
};

Policy Purchase with Customer Linking
Endpoint: POST /api/policies/purchase

Backend Code (server.js):
app.post('/api/policies/purchase', checkAuth, async (req, res) => {
    const connection = await pool.getConnection();
    try {
        await connection.beginTransaction();
        
        // Generate policy ID
        const policyId = `POL_${Date.now()}`;
        
        // Insert policy
        await connection.query(
            `INSERT INTO policy (policy_id, policy_type, coverage_amount, 
                                 premium_amount, start_date, end_date, status)
             VALUES (?, ?, ?, ?, ?, ?, 'PENDING_INITIAL_APPROVAL')`,
            [policyId, req.body.policy_type, req.body.coverage_amount, 
             req.body.premium_amount, req.body.start_date, req.body.end_date]
        );
        
        // Link to customer
        await connection.query(
            `INSERT INTO customer_policy (customer_id, policy_id)
             VALUES (?, ?)`,
            [req.customerId, policyId]
        );
        
        await connection.commit();
        res.json({ success: true, policyId });
    } catch (error) {
        await connection.rollback();
        res.status(500).json({ error: error.message });
    } finally {
        connection.release();
    }
});

Frontend Invocation (BuyPolicy.js):
const handlePurchase = async (product) => {
    const token = localStorage.getItem('token');
    const purchaseData = {
        policy_type: product.type,
        coverage_amount: product.coverage_amount,
        premium_amount: product.premium_amount,
        start_date: new Date().toISOString().split('T')[0],
        end_date: new Date(Date.now() + 365*24*60*60*1000)
                    .toISOString().split('T')[0]
    };
    
    const response = await axios.post(
        'http://localhost:3001/api/policies/purchase',
        purchaseData,
        { headers: { Authorization: `Bearer ${token}` } }
    );
    
    if (response.data.success) {
        alert(`Policy ${response.data.policyId} purchased successfully!`);
    }
};

================================================================================
END OF REPORT
================================================================================

RELATIONAL SCHEMA SUMMARY:

administrator(admin_id PK, name, email UK, phone, role, password)
customer(customer_id PK, name, email UK, phone, address, dob, gender, password)
agent(agent_id PK, name, email UK, phone, region)
policy(policy_id PK, policy_type, coverage_amount, premium_amount, 
       start_date, end_date, status, 
       initial_approval_by FK→administrator, initial_approval_date,
       final_approval_by FK→administrator, final_approval_date)
beneficiary(beneficiary_id PK, policy_id FK→policy, name, relationship, 
            phone, allocation_percentage)
customer_policy(customer_policy_id PK, customer_id FK→customer, 
                policy_id FK→policy)
agent_policy(agent_policy_id PK, agent_id FK→agent, policy_id FK→policy)
claim(claim_id PK, claim_amount, claim_status, claim_date, 
      customer_id FK→customer, policy_id FK→policy, description, 
      risk_score, workflow_id, current_step, 
      assigned_to FK→administrator, processing_time)
payment(payment_id PK, customer_policy_id FK→customer_policy, 
        status, payment_date, payment_mode)
reminder(notification_id PK, notification_date, status, message, 
         type, customer_id FK→customer)
admin_reminder(id PK, notification_id FK→reminder, admin_id FK→administrator)
audit_log(audit_log_id PK, user_id, user_type, action_type, 
          entity_id, timestamp, details)
workflows(workflow_id PK, workflow_name, description, created_at)
workflow_steps(step_id PK, workflow_id FK→workflows, step_number, 
               step_name, step_type, configuration, status, due_date)

KEY RELATIONSHIPS:
- Many-to-Many: customer ↔ policy (via customer_policy)
- Many-to-Many: agent ↔ policy (via agent_policy)
- One-to-Many: customer → claim, policy → claim, workflow → claim
- One-to-Many: administrator → policy (initial & final approval)
- One-to-Many: policy → beneficiary
- One-to-Many: customer → reminder
- One-to-Many: workflow → workflow_steps

================================================================================
Project Status: FULLY FUNCTIONAL
Last Updated: November 4, 2025
Total Tables: 14
Total Triggers: 5
Total Complex Queries: 10+
Backend Port: 3001
Frontend Port: 3000
================================================================================
